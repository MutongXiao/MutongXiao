---
title: node 中数据结构链表的实现&应用
authors: ['mutongxiao']
tags: ['数据结构', '链表']
categories: ['node']
date: '2022-5-08'
description: 链表是一系列节点（元素）组成的列表集合，节点在存储空间上是可以不连续的，每个节点都具有指向下一个节点的属性，通过next指针连在一起。
---

## 为什么不用数组存储数据

大多数情况下用数组是没问题的，数组仍然是很常用的数据结构。但如果从算法层面和数据可操控性上比较，链表结构显得要比数组灵活。

### 相比链表，数组的缺点

- 数组存数据的长度具有上限
- 数组存在塌陷问题

## 什么是链表

链表是一系列节点（元素）组成的列表集合，节点在存储空间上是可以不连续的，每个节点都具有指向下一个节点的属性，通过`next`指针连在一起。

链表分类：

- 单向链表
- 双向链表
- 循环列表

链表大体结构示意图如下：

```diagram
PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSI3MzFweCIgaGVpZ2h0PSIyMDFweCIgdmlld0JveD0iLTAuNSAtMC41IDczMSAyMDEiIGNvbnRlbnQ9IiZsdDtteGZpbGUgaG9zdD0mcXVvdDtlbWJlZC5kaWFncmFtcy5uZXQmcXVvdDsgbW9kaWZpZWQ9JnF1b3Q7MjAyMi0wNS0zMFQxNjoxNjo0NS4wMjRaJnF1b3Q7IGFnZW50PSZxdW90OzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMTAxLjAuNDk1MS42NCBTYWZhcmkvNTM3LjM2IEVkZy8xMDEuMC4xMjEwLjUzJnF1b3Q7IGV0YWc9JnF1b3Q7RmR0THo2VDNud1FxV3hNOWhXSEgmcXVvdDsgdmVyc2lvbj0mcXVvdDsxOC4xLjMmcXVvdDsgdHlwZT0mcXVvdDtlbWJlZCZxdW90OyZndDsmbHQ7ZGlhZ3JhbSBpZD0mcXVvdDt2eXVETXpibFYxcHR2Tk9kaTQyWiZxdW90OyBuYW1lPSZxdW90O1BhZ2UtMSZxdW90OyZndDs3VmxOYzVzd0VQMDF1bnBBNHZOb0NFa09hYVpUSDlvZVZTTWJUVER5Q0RtMisrc3JnVERHSW5IU3dTVHRPT09aZUo5V1grK3RkaEVHS0Y3dDdqaGVaMTlZU25JQXJYUUgwQTJBMExaUUlQOHBaRjhqcm85cVlNbHBxcDFhWUVaL2s2YW5SamMwSldYSFVUQ1dDN3J1Z25OV0ZHUXVPaGptbkcyN2JndVdkMmRkNHlVeGdOa2M1eWI2bmFZaXE5RUEraTErVCtneWEyYTJ2YkJ1V2VIR1dlK2t6SERLdGtjUVNnQ0tPV09pL3JiYXhTUlg1RFc4MVAxdVgyZzlMSXlUUXJ5bGcxTjNlTWI1UnU5TnIwdnNtODF5dGlsU292eHRnS0p0UmdXWnJmRmN0VzZsdkJMTHhDclh6ZWI4ZWtuUGhBdXlPNEwwZXU0SVd4SEI5OUxsRUI2YUd4MGNkcUR0YlV1MWp6U1dIZEVNbTQ1WXk3czhqTjB5SUw5b0V2b0pjZDlEaURVS0lkRHJFZ0o3Q0xGaER5SGVBSHo0Qmg4UHRIZ2k2UU10QlVodVFSU0RJQUJKQ0VJRW9nUWtBWmphWUNvUkgwU1JBaE1QaEFrSW5NWTVOUGlVTklndWFhWGc3SW5FTEdkY0lnVXJwR2Uwb0hsK0F1R2NMZ3RwemlXNVJPS1JJcFhLY3pyVkRTdWFwbXFhWHBXNk9pNVlJV1o2VVhaajE1bkhkaTRUMlllQVBSWXk3QkhTSFVESTBCRHludUQwTTRzeE1Qa0lkc2tQWFlOOHI0ZDdOQUQzTmp5ZlZVaVJUbFZwVWd6bXVDenB2Q3ZENndSSlh2aitoMjZzakovS21MaU5lYk03YnJ6WmErdEZZa25hS1lFbXJVZTB1YStFTENjNUZ2UzVXemo3dU5RemZHVlVycVJWTFFnNnFpSDdSSTZTYmZpYzZGN0hoZTVrSU9pZUdVaGd2aVRDR0tpUzlyRHR0Nmx0RnRVa0p5dWlCKzQ1YmNNZnNWS2VMbG9zSDhoQzZlRzB5RGN0a1lLWTdMN0lxNURMWkVjaVI0aldpb0NLRWplU0gwbFNyS0xJbGF1TnBXMjN0dndvZHk1aVZzZ05ZRnBGRU1HbDJKSlNWQkVyc01DL3FyMWU2RkJEUHp4YkdvTkxIV3J6VWVGUnlYblZlR0NOZzI3VlJKYVp1Qyttc1RkZTRwNVlBZW9tYi85TThxNnNyNFJUdVM4Vkt2OUVSa2ZPaVp3TnBlL042QTYwSnFGbnRYL082K01PbU9DRDgxRXg5aVhCZ1I5NFNiRE5oOHRyeGJ0TU5uU2M4enBmS2hzMjRYT3RlT05xUEdiRk82ejJlbFY1WjJGenJkUEM5cGRYRlRjOEdjZ09KKzZsYWxrajcyZXFaYWNFakZyTElMb211VEdTbkdkL1lKSzczdEEvU3VaUm4xZmU4REwvV3N2NlNwRG5EMVRMZk5jZnNaYVp0L1hIamZMb1A5UC8zenR1ZysyZW5EclFPMjVwdHI5UzFscTF2L1dpNUE4PSZsdDsvZGlhZ3JhbSZndDsmbHQ7L214ZmlsZSZndDsiPjxkZWZzPjxjbGlwUGF0aCBpZD0ibXgtY2xpcC0xODMtMTAwLTcyLTMwLTAiPjxyZWN0IHg9IjE4MyIgeT0iMTAwIiB3aWR0aD0iNzIiIGhlaWdodD0iMzAiLz48L2NsaXBQYXRoPjxjbGlwUGF0aCBpZD0ibXgtY2xpcC0xODQtMTI1LTcyLTMwLTAiPjxyZWN0IHg9IjE4NCIgeT0iMTI1IiB3aWR0aD0iNzIiIGhlaWdodD0iMzAiLz48L2NsaXBQYXRoPjxjbGlwUGF0aCBpZD0ibXgtY2xpcC0zNDQtMTAwLTcyLTMwLTAiPjxyZWN0IHg9IjM0NCIgeT0iMTAwIiB3aWR0aD0iNzIiIGhlaWdodD0iMzAiLz48L2NsaXBQYXRoPjxjbGlwUGF0aCBpZD0ibXgtY2xpcC0zNDQtMTI1LTcyLTMwLTAiPjxyZWN0IHg9IjM0NCIgeT0iMTI1IiB3aWR0aD0iNzIiIGhlaWdodD0iMzAiLz48L2NsaXBQYXRoPjxjbGlwUGF0aCBpZD0ibXgtY2xpcC01MTQtMTI1LTcyLTMwLTAiPjxyZWN0IHg9IjUxNCIgeT0iMTI1IiB3aWR0aD0iNzIiIGhlaWdodD0iMzAiLz48L2NsaXBQYXRoPjxjbGlwUGF0aCBpZD0ibXgtY2xpcC01MTQtMTAwLTcyLTMwLTAiPjxyZWN0IHg9IjUxNCIgeT0iMTAwIiB3aWR0aD0iNzIiIGhlaWdodD0iMzAiLz48L2NsaXBQYXRoPjwvZGVmcz48Zz48cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iNzMwIiBoZWlnaHQ9IjIwMCIgcng9IjMwIiByeT0iMzAiIGZpbGw9InJnYigyNTUsIDI1NSwgMjU1KSIgc3Ryb2tlPSJyZ2IoMCwgMCwgMCkiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48cmVjdCB4PSIxNjAiIHk9IjEwMCIgd2lkdGg9IjEyMCIgaGVpZ2h0PSI2MCIgZmlsbD0icmdiKDI1NSwgMjU1LCAyNTUpIiBzdHJva2U9InJnYigwLCAwLCAwKSIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjxyZWN0IHg9IjAiIHk9IjIwIiB3aWR0aD0iMTkwIiBoZWlnaHQ9IjUwIiBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC41IC0wLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHBvaW50ZXItZXZlbnRzPSJub25lIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiIHN0eWxlPSJvdmVyZmxvdzogdmlzaWJsZTsgdGV4dC1hbGlnbjogbGVmdDsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogdW5zYWZlIGNlbnRlcjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgY2VudGVyOyB3aWR0aDogMTg4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogNDVweDsgbWFyZ2luLWxlZnQ6IDFweDsiPjxkaXYgZGF0YS1kcmF3aW8tY29sb3JzPSJjb2xvcjogcmdiKDAsIDAsIDApOyAiIHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDE0cHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMCwgMCwgMCk7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IGZvbnQtd2VpZ2h0OiBib2xkOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyBvdmVyZmxvdy13cmFwOiBub3JtYWw7Ij5MaW5rZWRMaXN077yI6ZO+6KGo57uT5p6E77yJPC9kaXY+PC9kaXY+PC9kaXY+PC9mb3JlaWduT2JqZWN0Pjx0ZXh0IHg9Ijk1IiB5PSI0OSIgZmlsbD0icmdiKDAsIDAsIDApIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjE0cHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtd2VpZ2h0PSJib2xkIj5MaW5rZWRMaXN077yI6ZO+6KGo57uT5p6E77yJPC90ZXh0Pjwvc3dpdGNoPjwvZz48cmVjdCB4PSIzMiIgeT0iMTE1IiB3aWR0aD0iNjAiIGhlaWdodD0iMzAiIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0wLjUgLTAuNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3QgcG9pbnRlci1ldmVudHM9Im5vbmUiIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHJlcXVpcmVkRmVhdHVyZXM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSIgc3R5bGU9Im92ZXJmbG93OiB2aXNpYmxlOyB0ZXh0LWFsaWduOiBsZWZ0OyI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiB1bnNhZmUgY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IHVuc2FmZSBjZW50ZXI7IHdpZHRoOiA1OHB4OyBoZWlnaHQ6IDFweDsgcGFkZGluZy10b3A6IDEzMHB4OyBtYXJnaW4tbGVmdDogMzNweDsiPjxkaXYgZGF0YS1kcmF3aW8tY29sb3JzPSJjb2xvcjogcmdiKDAsIDAsIDApOyAiIHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDE0cHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMCwgMCwgMCk7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IHdoaXRlLXNwYWNlOiBub3JtYWw7IG92ZXJmbG93LXdyYXA6IG5vcm1hbDsiPkhlYWQ8L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iNjIiIHk9IjEzNCIgZmlsbD0icmdiKDAsIDAsIDApIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjE0cHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiPkhlYWQ8L3RleHQ+PC9zd2l0Y2g+PC9nPjxwYXRoIGQ9Ik0gODggMTMwIEwgMTUxLjYzIDEzMCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJyZ2IoMCwgMCwgMCkiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMTU2Ljg4IDEzMCBMIDE0OS44OCAxMzMuNSBMIDE1MS42MyAxMzAgTCAxNDkuODggMTI2LjUgWiIgZmlsbD0icmdiKDAsIDAsIDApIiBzdHJva2U9InJnYigwLCAwLCAwKSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PHJlY3QgeD0iMTc5IiB5PSIxMDAiIHdpZHRoPSI4MCIgaGVpZ2h0PSIzMCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgZmlsbD0icmdiKDAsIDAsIDApIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBjbGlwLXBhdGg9InVybCgjbXgtY2xpcC0xODMtMTAwLTcyLTMwLTApIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjE0cHgiPjx0ZXh0IHg9IjIxOC41IiB5PSIxMjAuNSI+RWxlbWVudDwvdGV4dD48L2c+PHJlY3QgeD0iMTgwIiB5PSIxMjUiIHdpZHRoPSI4MCIgaGVpZ2h0PSIzMCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgZmlsbD0icmdiKDAsIDAsIDApIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBjbGlwLXBhdGg9InVybCgjbXgtY2xpcC0xODQtMTI1LTcyLTMwLTApIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjE0cHgiPjx0ZXh0IHg9IjIxOS41IiB5PSIxNDUuNSI+TmV4dDwvdGV4dD48L2c+PHBhdGggZD0iTSAyNDAgMTQyIEwgMzE0LjU5IDE0MiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJyZ2IoMCwgMCwgMCkiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMzE5Ljg0IDE0MiBMIDMxMi44NCAxNDUuNSBMIDMxNC41OSAxNDIgTCAzMTIuODQgMTM4LjUgWiIgZmlsbD0icmdiKDAsIDAsIDApIiBzdHJva2U9InJnYigwLCAwLCAwKSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PHJlY3QgeD0iMzIwIiB5PSIxMDAiIHdpZHRoPSIxMjAiIGhlaWdodD0iNjAiIGZpbGw9InJnYigyNTUsIDI1NSwgMjU1KSIgc3Ryb2tlPSJyZ2IoMCwgMCwgMCkiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48cmVjdCB4PSIzNDAiIHk9IjEwMCIgd2lkdGg9IjgwIiBoZWlnaHQ9IjMwIiBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyBmaWxsPSJyZ2IoMCwgMCwgMCkiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGNsaXAtcGF0aD0idXJsKCNteC1jbGlwLTM0NC0xMDAtNzItMzAtMCkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTRweCI+PHRleHQgeD0iMzc5LjUiIHk9IjEyMC41Ij5FbGVtZW50PC90ZXh0PjwvZz48cmVjdCB4PSIzNDAiIHk9IjEyNSIgd2lkdGg9IjgwIiBoZWlnaHQ9IjMwIiBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyBmaWxsPSJyZ2IoMCwgMCwgMCkiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGNsaXAtcGF0aD0idXJsKCNteC1jbGlwLTM0NC0xMjUtNzItMzAtMCkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTRweCI+PHRleHQgeD0iMzc5LjUiIHk9IjE0NS41Ij5OZXh0PC90ZXh0PjwvZz48cGF0aCBkPSJNIDQwMCAxNDAgTCA0ODMuNjMgMTM5LjU0IiBmaWxsPSJub25lIiBzdHJva2U9InJnYigwLCAwLCAwKSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0ic3Ryb2tlIi8+PHBhdGggZD0iTSA0ODguODggMTM5LjUxIEwgNDgxLjkgMTQzLjA1IEwgNDgzLjYzIDEzOS41NCBMIDQ4MS44NiAxMzYuMDUgWiIgZmlsbD0icmdiKDAsIDAsIDApIiBzdHJva2U9InJnYigwLCAwLCAwKSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PHJlY3QgeD0iNDkwIiB5PSIxMDAiIHdpZHRoPSIxMjAiIGhlaWdodD0iNjAiIGZpbGw9InJnYigyNTUsIDI1NSwgMjU1KSIgc3Ryb2tlPSJyZ2IoMCwgMCwgMCkiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48cmVjdCB4PSI1MTAiIHk9IjEyNSIgd2lkdGg9IjgwIiBoZWlnaHQ9IjMwIiBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyBmaWxsPSJyZ2IoMCwgMCwgMCkiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGNsaXAtcGF0aD0idXJsKCNteC1jbGlwLTUxNC0xMjUtNzItMzAtMCkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTRweCI+PHRleHQgeD0iNTQ5LjUiIHk9IjE0NS41Ij5OZXh0PC90ZXh0PjwvZz48cmVjdCB4PSI1MTAiIHk9IjEwMCIgd2lkdGg9IjgwIiBoZWlnaHQ9IjMwIiBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyBmaWxsPSJyZ2IoMCwgMCwgMCkiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGNsaXAtcGF0aD0idXJsKCNteC1jbGlwLTUxNC0xMDAtNzItMzAtMCkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTRweCI+PHRleHQgeD0iNTQ5LjUiIHk9IjEyMC41Ij5FbGVtZW50PC90ZXh0PjwvZz48cGF0aCBkPSJNIDU3MCAxNDAgTCA2NTAuNjMgMTM5LjU0IiBmaWxsPSJub25lIiBzdHJva2U9InJnYigwLCAwLCAwKSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0ic3Ryb2tlIi8+PHBhdGggZD0iTSA2NTUuODggMTM5LjUxIEwgNjQ4LjkgMTQzLjA1IEwgNjUwLjYzIDEzOS41NCBMIDY0OC44NiAxMzYuMDUgWiIgZmlsbD0icmdiKDAsIDAsIDApIiBzdHJva2U9InJnYigwLCAwLCAwKSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PHJlY3QgeD0iNjU3IiB5PSIxMjUiIHdpZHRoPSI2MCIgaGVpZ2h0PSIzMCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5IiBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDU4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMTQwcHg7IG1hcmdpbi1sZWZ0OiA2NThweDsiPjxkaXYgZGF0YS1kcmF3aW8tY29sb3JzPSJjb2xvcjogcmdiKDAsIDAsIDApOyAiIHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDE0cHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMCwgMCwgMCk7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IHdoaXRlLXNwYWNlOiBub3JtYWw7IG92ZXJmbG93LXdyYXA6IG5vcm1hbDsiPk51bGw8L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iNjg3IiB5PSIxNDQiIGZpbGw9InJnYigwLCAwLCAwKSIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxNHB4IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5OdWxsPC90ZXh0Pjwvc3dpdGNoPjwvZz48L2c+PHN3aXRjaD48ZyByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiLz48YSB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLC01KSIgeGxpbms6aHJlZj0iaHR0cHM6Ly93d3cuZGlhZ3JhbXMubmV0L2RvYy9mYXEvc3ZnLWV4cG9ydC10ZXh0LXByb2JsZW1zIiB0YXJnZXQ9Il9ibGFuayI+PHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxMHB4IiB4PSI1MCUiIHk9IjEwMCUiPlRleHQgaXMgbm90IFNWRyAtIGNhbm5vdCBkaXNwbGF5PC90ZXh0PjwvYT48L3N3aXRjaD48L3N2Zz4=
```

本文章主要介绍上面面列出的单向链表的实现和应用

## 单向链表

实现思路

1. 先定义链表上每个节点的结构

```javascript
// 链表节点的结构
class Node {
  // element: 节点存储的数据
  // next: 下一个节点的指向
  constructor(element, next) {
    this.element = element;
    this.next = next;
  }
}
```

2. 单向链表结构定义，链表的初始结构为 `head -->null` ，具有一个表面其大小的`size`属性，即节点个数。除此之外，还应有操作链表的方法，即增、删、改、查。

```javascript
class LinkedList {
  constructor(head, size) {
    this.head = null;
    this.size = 0;
  }
  // 根据索引，获取节点
  _getNode(index) {
    if (index < 0 || index >= this.size) {
      throw new Error('越界了');
    }
    let currentNode = this.head;
    for (let i = 0; i < index; i++) {
      currentNode = currentNode.next;
    }
    return currentNode;
  }
  // 往列表插入节点
  add(index, element) {
    if (arguments.length == 1) {
      element = index;
      index = this.size;
    }
    if (index < 0 || index > this.size) {
      throw new Error('cross the border');
    }
    if (index == 0) {
      let head = this.head; // 保存原有 head 的指向
      this.head = new Node(element, head);
    } else {
      let prevNode = this._getNode(index - 1);
      prevNode.next = new Node(element, prevNode.next);
    }
    this.size++;
  }

  // 删除节点
  remove(index) {
    let rmNode = null;
    if (index == 0) {
      rmNode = this.head;
      if (!rmNode) {
        return undefined;
      }
      this.head = rmNode.next;
    } else {
      let prevNode = this._getNode(index - 1);
      rmNode = prevNode.next;
      prevNode.next = rmNode.next;
    }
    this.size--;
    return rmNode;
  }
  // 修改节点 (改)
  set(index, element) {
    let node = this._getNode(index);
    node.element = element;
  }
  // 获取节点（查）
  get(index) {
    return this._getNode(index);
  }
  // 清空链表
  clear() {
    this.head = null;
    this.size = 0;
  }
}

const l1 = new LinkedList();
l1.add('node1');
l1.add('node2');
l1.add(1, 'node3');
// l1.remove(1)
l1.set(1, 'node3-3');
// let a = l1.get(0)
l1.clear();
console.log(l1);
```

### 基于单向链表实现队列

队列是一个先进先出的数据结构

```javascript
class Queue {
  constructor() {
    this.linkedList = new LinkedList();
  }
  enQueue(data) {
    this.linkedList.add(data);
  }
  deQueue() {
    return this.linkedList.remove(0);
  }
}

const q = new Queue();

q.enQueue('node1');
q.enQueue('node2');

let a = q.deQueue();
a = q.deQueue();
a = q.deQueue();

console.log(a);
```

### 基于链表队列结构，模拟实现 node 文件可写流操作

这里先对 node 的流做个简单介绍，

**node.js 中的四种流：**

- Readable 可读流，能够实现数的读取
- Writeable 可写流。能够实现数据的写操作
- Duplex 双工流，即可读又可写
- Transform 转换流，可读可写，还能在数据读取过程中对数据进行转换

**node.js 中流的特点：**

- node 中的流模块 Stream，实现了上面四中流的具体抽象
- 所有的流都继承自 EventEmitter 事件发布订阅消息机制
- 流模式有流动模式，暂停模式

**数据读写可能存在的问题**

内存溢出，GC 频繁调用，其他进程变慢，所以在 node.js 中的 stream 已实现了对应的背压机制。

![readablestream_1-6-2022_1637_.jpeg](/readablestream_1-6-2022_1637_.jpeg)
![writeablestream_1-6-2022_11229_.jpeg](/writeablestream_1-6-2022_11229_.jpeg)

在了解了流的基本概念之后，下面利用链表队列来模拟实现可写流，这里链表队列的主要作用是充当可写流中的缓存区

```javascript
const fs = require('fs');
const EventsEmitter = require('events');
const Queue = require('./linkedlist');

class MyWriteStream extends EventsEmitter {
  constructor(path, options = {}) {
    super();
    this.path = path;
    this.flags = options.flags || 'w';
    this.mode = options.mode || 438;
    this.autoClose = options.autoClose || true;
    this.start = options.start || 0;
    this.encoding = options.encoding || 'utf8';
    this.highWaterMark = options.highWaterMark || 16 * 1024;

    this.open();

    this.writeoffset = this.start;
    this.writing = false;
    this.writeLen = 0;
    this.needDrain = false;
    this.cache = new Queue();
  }
  open() {
    // 原生 fs.open
    fs.open(this.path, this.flags, (err, fd) => {
      if (err) {
        this.emit('error', err);
      }
      // 正常打开文件
      this.fd = fd;
      this.emit('open', fd);
    });
  }
  write(chunk, encoding, cb) {
    chunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);

    this.writeLen += chunk.length;
    let flag = this.writeLen < this.highWaterMark;
    this.needDrain = !flag;

    if (this.writing) {
      // 当前正在执行写入，所以内容应该排队
      this.cache.enQueue({ chunk, encoding, cb });
    } else {
      this.writing = true;
      // 当前不是正在写入那么就执行写入
      this._write(chunk, encoding, () => {
        cb();
        // 清空排队的内容
        this._clearBuffer();
      });
    }
    return flag;
  }
  _write(chunk, encoding, cb) {
    if (typeof this.fd !== 'number') {
      return this.once('open', () => {
        return this._write(chunk, encoding, cb);
      });
    }
    fs.write(
      this.fd,
      chunk,
      this.start,
      chunk.length,
      this.writeoffset,
      (err, written) => {
        this.writeoffset += written;
        this.writeLen -= written;

        cb && cb();
      },
    );
  }
  _clearBuffer() {
    let data = this.cache.deQueue();
    if (data) {
      this._write(data.element.chunk, data.element.encoding, () => {
        data.element.cb && data.element.cb();
        this._clearBuffer();
      });
    } else {
      if (this.needDrain) {
        this.needDrain = false;
        this.emit('drain');
      }
    }
  }
}
```

使用示例：

```js
const ws = new MyWriteStream('./demo.txt', {});

ws.on('open', fd => {
  console.log('open---->', fd);
});

let flag = ws.write('1', 'utf8', () => {
  console.log('ok1');
});

flag = ws.write('10', 'utf8', () => {
  console.log('ok1');
});

flag = ws.write('我是一段输入数据', 'utf8', () => {
  console.log('ok3');
});

ws.on('drain', () => {
  console.log('drain');
});
```
